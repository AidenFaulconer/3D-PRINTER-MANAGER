import"./react-vendor-97d11c3b.js";const T=a=>{let o;const e=new Set,r=(d,s)=>{const S=typeof d=="function"?d(o):d;if(!Object.is(S,o)){const y=o;o=s??(typeof S!="object"||S===null)?S:Object.assign({},o,S),e.forEach(f=>f(o,y))}},t=()=>o,i={setState:r,getState:t,getInitialState:()=>v,subscribe:d=>(e.add(d),()=>e.delete(d))},v=o=a(r,t,i);return i},x=a=>a?T(a):T,b=new Map,_=a=>{const o=b.get(a);return o?Object.fromEntries(Object.entries(o.stores).map(([e,r])=>[e,r.getState()])):{}},w=(a,o,e)=>{if(a===void 0)return{type:"untracked",connection:o.connect(e)};const r=b.get(e.name);if(r)return{type:"tracked",store:a,...r};const t={connection:o.connect(e),stores:{}};return b.set(e.name,t),{type:"tracked",store:a,...t}},C=(a,o)=>{if(o===void 0)return;const e=b.get(a);e&&(delete e.stores[o],Object.keys(e.stores).length===0&&b.delete(a))},D=a=>{var o,e;if(!a)return;const r=a.split(`
`),t=r.findIndex(h=>h.includes("api.setState"));if(t<0)return;const c=((o=r[t+1])==null?void 0:o.trim())||"";return(e=/.+ (.+) .+/.exec(c))==null?void 0:e[1]},A=(a,o={})=>(e,r,t)=>{const{enabled:c,anonymousActionType:h,store:i,...v}=o;let d;try{d=(c??!1)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!d)return a(e,r,t);const{connection:s,...S}=w(i,d,v);let y=!0;t.setState=(n,m,l)=>{const u=e(n,m);if(!y)return u;const p=l===void 0?{type:h||D(new Error().stack)||"anonymous"}:typeof l=="string"?{type:l}:l;return i===void 0?(s==null||s.send(p,r()),u):(s==null||s.send({...p,type:`${i}/${p.type}`},{..._(v.name),[i]:t.getState()}),u)},t.devtools={cleanup:()=>{s&&typeof s.unsubscribe=="function"&&s.unsubscribe(),C(v.name,i)}};const f=(...n)=>{const m=y;y=!1,e(...n),y=m},g=a(t.setState,r,t);if(S.type==="untracked"?s==null||s.init(g):(S.stores[S.store]=t,s==null||s.init(Object.fromEntries(Object.entries(S.stores).map(([n,m])=>[n,n===S.store?g:m.getState()])))),t.dispatchFromDevtools&&typeof t.dispatch=="function"){let n=!1;const m=t.dispatch;t.dispatch=(...l)=>{m(...l)}}return s.subscribe(n=>{var m;switch(n.type){case"ACTION":if(typeof n.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return O(n.payload,l=>{if(l.type==="__setState"){if(i===void 0){f(l.state);return}Object.keys(l.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const u=l.state[i];if(u==null)return;JSON.stringify(t.getState())!==JSON.stringify(u)&&f(u);return}t.dispatchFromDevtools&&typeof t.dispatch=="function"&&t.dispatch(l)});case"DISPATCH":switch(n.payload.type){case"RESET":return f(g),i===void 0?s==null?void 0:s.init(t.getState()):s==null?void 0:s.init(_(v.name));case"COMMIT":if(i===void 0){s==null||s.init(t.getState());return}return s==null?void 0:s.init(_(v.name));case"ROLLBACK":return O(n.state,l=>{if(i===void 0){f(l),s==null||s.init(t.getState());return}f(l[i]),s==null||s.init(_(v.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return O(n.state,l=>{if(i===void 0){f(l);return}JSON.stringify(t.getState())!==JSON.stringify(l[i])&&f(l[i])});case"IMPORT_STATE":{const{nextLiftedState:l}=n.payload,u=(m=l.computedStates.slice(-1)[0])==null?void 0:m.state;if(!u)return;f(i===void 0?u:u[i]),s==null||s.send(null,l);return}case"PAUSE_RECORDING":return y=!y}return}}),g},F=A,O=(a,o)=>{let e;try{e=JSON.parse(a)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}e!==void 0&&o(e)},N=a=>(o,e,r)=>{const t=r.subscribe;return r.subscribe=(h,i,v)=>{let d=h;if(i){const s=(v==null?void 0:v.equalityFn)||Object.is;let S=h(r.getState());d=y=>{const f=h(y);if(!s(S,f)){const g=S;i(S=f,g)}},v!=null&&v.fireImmediately&&i(S,S)}return t(d)},a(o,e,r)},P=N;function j(a,o){let e;try{e=a()}catch{return}return{getItem:t=>{var c;const h=v=>v===null?null:JSON.parse(v,o==null?void 0:o.reviver),i=(c=e.getItem(t))!=null?c:null;return i instanceof Promise?i.then(h):h(i)},setItem:(t,c)=>e.setItem(t,JSON.stringify(c,o==null?void 0:o.replacer)),removeItem:t=>e.removeItem(t)}}const E=a=>o=>{try{const e=a(o);return e instanceof Promise?e:{then(r){return E(r)(e)},catch(r){return this}}}catch(e){return{then(r){return this},catch(r){return E(r)(e)}}}},k=(a,o)=>(e,r,t)=>{let c={storage:j(()=>localStorage),partialize:n=>n,version:0,merge:(n,m)=>({...m,...n}),...o},h=!1;const i=new Set,v=new Set;let d=c.storage;if(!d)return a((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${c.name}', the given storage is currently unavailable.`),e(...n)},r,t);const s=()=>{const n=c.partialize({...r()});return d.setItem(c.name,{state:n,version:c.version})},S=t.setState;t.setState=(n,m)=>(S(n,m),s());const y=a((...n)=>(e(...n),s()),r,t);t.getInitialState=()=>y;let f;const g=()=>{var n,m;if(!d)return;h=!1,i.forEach(u=>{var p;return u((p=r())!=null?p:y)});const l=((m=c.onRehydrateStorage)==null?void 0:m.call(c,(n=r())!=null?n:y))||void 0;return E(d.getItem.bind(d))(c.name).then(u=>{if(u)if(typeof u.version=="number"&&u.version!==c.version){if(c.migrate){const p=c.migrate(u.state,u.version);return p instanceof Promise?p.then(I=>[!0,I]):[!0,p]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,u.state];return[!1,void 0]}).then(u=>{var p;const[I,R]=u;if(f=c.merge(R,(p=r())!=null?p:y),e(f,!0),I)return s()}).then(()=>{l==null||l(f,void 0),f=r(),h=!0,v.forEach(u=>u(f))}).catch(u=>{l==null||l(void 0,u)})};return t.persist={setOptions:n=>{c={...c,...n},n.storage&&(d=n.storage)},clearStorage:()=>{d==null||d.removeItem(c.name)},getOptions:()=>c,rehydrate:()=>g(),hasHydrated:()=>h,onHydrate:n=>(i.add(n),()=>{i.delete(n)}),onFinishHydration:n=>(v.add(n),()=>{v.delete(n)})},c.skipHydration||g(),f||y},L=k;export{x as c,F as d,L as p,P as s};
